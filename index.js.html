<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>index.js - Documentation</title>
    
    
    <meta property="og:title" content="TheRolfFR/firestorm-db: Self hosted Firestore-like database"/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content="https://github.com/TheRolfFR/firestorm-db/raw/main/img/firestorm-128.png"/>
    <meta property="og:site_name" content="firestorm-db"/>
    <meta property="og:url" content="https://github.com/TheRolfFR/firestorm-db/"/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="wrap">
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/TheRolfFR/firestorm" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><h3>Classes</h3><ul><li><a href="Collection.html">Collection</a><ul class='methods'><li data-type='method'><a href="Collection.html#add">add</a></li><li data-type='method'><a href="Collection.html#add">add</a></li><li data-type='method'><a href="Collection.html#addBulk">addBulk</a></li><li data-type='method'><a href="Collection.html#addBulk">addBulk</a></li><li data-type='method'><a href="Collection.html#editField">editField</a></li><li data-type='method'><a href="Collection.html#editField">editField</a></li><li data-type='method'><a href="Collection.html#editFieldBulk">editFieldBulk</a></li><li data-type='method'><a href="Collection.html#editFieldBulk">editFieldBulk</a></li><li data-type='method'><a href="Collection.html#get">get</a></li><li data-type='method'><a href="Collection.html#get">get</a></li><li data-type='method'><a href="Collection.html#random">random</a></li><li data-type='method'><a href="Collection.html#random">random</a></li><li data-type='method'><a href="Collection.html#read_raw">read_raw</a></li><li data-type='method'><a href="Collection.html#read_raw">read_raw</a></li><li data-type='method'><a href="Collection.html#remove">remove</a></li><li data-type='method'><a href="Collection.html#remove">remove</a></li><li data-type='method'><a href="Collection.html#removeBulk">removeBulk</a></li><li data-type='method'><a href="Collection.html#removeBulk">removeBulk</a></li><li data-type='method'><a href="Collection.html#search">search</a></li><li data-type='method'><a href="Collection.html#search">search</a></li><li data-type='method'><a href="Collection.html#searchKeys">searchKeys</a></li><li data-type='method'><a href="Collection.html#searchKeys">searchKeys</a></li><li data-type='method'><a href="Collection.html#select">select</a></li><li data-type='method'><a href="Collection.html#select">select</a></li><li data-type='method'><a href="Collection.html#set">set</a></li><li data-type='method'><a href="Collection.html#set">set</a></li><li data-type='method'><a href="Collection.html#setBulk">setBulk</a></li><li data-type='method'><a href="Collection.html#setBulk">setBulk</a></li><li data-type='method'><a href="Collection.html#sha1">sha1</a></li><li data-type='method'><a href="Collection.html#sha1">sha1</a></li><li data-type='method'><a href="Collection.html#write_raw">write_raw</a></li><li data-type='method'><a href="Collection.html#write_raw">write_raw</a></li></ul></li><li></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">index.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>try {
  if(typeof process === 'object') {
    var axios = require("axios").default
  }
} catch(_error) {}

/**
 * @typedef {Object} SearchOption
 * @property {String} field The field you want to search in
 * @property {"!=" | "==" | ">=" | "&lt;=" | "&lt;" | ">" | "in" | "includes" | "startsWith" | "endsWith" | "array-contains" | "array-contains-any" | "array-length-(eq|df|gt|lt|ge|le)" } criteria // filter criteria
 * @property {String | Number | Boolean | Array } value // the value you want to compare
 * @property {Boolean} ignoreCase Ignore case on search string
 */

/**
 * @typedef {Object} EditObject
 * @property {String | Number } id the affected element
 * @property {String} field The field you want to edit
 * @property {"set" | "remove" | "append" | "increment" | "decrement" | "array-push" | "array-delete" | "array-splice"} operation Wanted operation on field
 * @property {String | Number | Boolean | Array } [value] // the value you want to compare
 */

/**
 * @typedef {Object} SelectOption
 * @property {Array&lt;String>} fields Chosen fields to eventually return
 */

/**
 * @import {AxiosPromise} from 'axios'
 */

/**
 * @ignore
 */
let _address = undefined

/**
 * @ignore
 */
let _token = undefined

const ID_FIELD_NAME = 'id'

const readAddress = () => {
  if(!_address)
    throw new Error('Firestorm address was not configured')
  
  return _address + 'get.php'
}
const writeAddress = () => {
  if(!_address)
    throw new Error('Firestorm address was not configured')
  
  return _address + 'post.php'
}

const writeToken = () => {
  if(!_token)
    throw new Error('Firestorm token was not configured')

  return _token
}

/**
 * Class representing a collection
 * @template T
 */
class Collection {
  /** 
   * @param {String} name The name of the Collection
   * @param {Function?} addMethods Additional methods and data to add to the objects
   */
  constructor(name, addMethods = el => el) {
    this.addMethods = addMethods
    this.collectionName = name
  }

  /**
   * Add user methods to the returned data
   * @private
   * @ignore
   * @param {AxiosPromise} req Incoming request 
   * @returns {Object|Object[]}
   */
  __add_methods(req) {
    return new Promise((resolve, reject) => {
      req
      .then(el => {
        if(Array.isArray(el)) {
          return resolve(el.map(e => this.addMethods(e)))
        }

        el[Object.keys(el)[0]][ID_FIELD_NAME] = Object.keys(el)[0]
        el = el[Object.keys(el)[0]]

        // else on the object itself
        return resolve(this.addMethods(el))
      }).catch(err => reject(err))
    })
  }

  /**
   * Auto-extracts data from Axios request
   * @private
   * @ignore
   * @param {AxiosPromise} request The Axios concerned request
   */
  __extract_data(request) {
    return new Promise((resolve, reject) => {
      request.then(res => {
        if ('data' in res) return resolve(res.data)
        return resolve(res)
      })
      .catch(err => reject(err))
    })
  }

  /**
   * Send get request and extract data from response
   * @private
   * @ignore
   * @param {Object} data Body data
   * @returns {Promise&lt;Object|Object[]>} data out
   */
  __get_request(data) {
    const request = typeof process === 'object' ? axios.get(readAddress(), {
      data: data
    }) : axios.post(readAddress(), data)
    return this.__extract_data(request)
  }

  /**
   * Get an element from the collection
   * @param {String|Number} id The entry ID
   * @returns {Promise&lt;T>} Result entry you may be looking for
   */
  get(id) {
    return this.__add_methods(this.__get_request({
      "collection": this.collectionName,
      "command": "get",
      "id": id
    }))
  }

  /**
   * @returns {String} returns sha1 hash of the file. can be used to see if same file content without downloding the file for example
   */
  sha1() {
    return this.__get_request({
      "collection": this.collectionName,
      "command": "sha1",
    })
  }

  /**
   * Search through collection
   * @param {SearchOption[]} searchOptions Array of search options
   * @param {(Number|false|true)?} random Random result seed, disabled by default, but can activated with true or a given seed
   * @returns {Promise&lt;T[]>}
   */
  search(searchOptions, random=false) {
    if(!Array.isArray(searchOptions))
      return Promise.reject(new Error('searchOptions shall be an array'))

    searchOptions.forEach(searchOption => {
      if(searchOption.field === undefined || searchOption.criteria === undefined || searchOption.value === undefined)
        return Promise.reject(new Error('Missing fields in searchOptions array'))

      if(typeof searchOption.field !== 'string')
        return Promise.reject(new Error(`${JSON.stringify(searchOption)} search option field is not a string`))

      if(searchOption.criteria == 'in' &amp;&amp; !Array.isArray(searchOption.value))
        return Promise.reject(new Error('in takes an array of values'))

      //TODO: add more strict value field warnings in JS and PHP
    })

    let params = {
      "collection": this.collectionName,
      "command": "search",
      "search": searchOptions
    }

    if(random !== false) {
      if(random === true) {
        params.random = {}
      } else {
        let seed = parseInt(random)
        if(isNaN(seed)) return Promise.reject(new Error('random takes as parameter true, false or an integer value'))
        params.random = {
          "seed": seed
        }
      }
    }

    return new Promise((resolve, reject) => {
      let raw
      this.__get_request(params).then(res => {
        const arr = []

        raw = res
        Object.keys(res).forEach(contribID => {
          const tmp = res[contribID]
          tmp[ID_FIELD_NAME] = contribID
          arr.push(tmp)
        })

        resolve(this.__add_methods(Promise.resolve(arr)))

      }).catch(err => {
        err.raw = raw
        reject(err)
      })
    })
  }

  /**
   * Search specific keys through collection
   * @param {String[]|Number[]} keys Wanted keys
   * @returns {Promise&lt;T[]>} Search results
   */
  searchKeys(keys) {
    if(!Array.isArray(keys))
      return Promise.reject('Incorrect keys')

    return new Promise((resolve, reject) => {
      this.__get_request({
        "collection": this.collectionName,
        "command": "searchKeys",
        "search": keys
      }).then(res => {
        const arr = []
        Object.keys(res).forEach(contribID => {
          const tmp = res[contribID]
          tmp[ID_FIELD_NAME] = contribID
          arr.push(tmp)
        })

        resolve(this.__add_methods(Promise.resolve(arr)))

      }).catch(err => reject(err))
    })
  }

  /**
   * Returns the whole content of the file
   * @returns {Promise} // the get promise of the collection raw file content
   */
  read_raw() {
    return new Promise((resolve, reject) => {
      this.__get_request({
        "collection": this.collectionName,
        "command": "read_raw"
      })
      .then(data => {
        Object.keys(data).forEach(key => {
          data[key][ID_FIELD_NAME] = key
          this.addMethods(data[key])
        })

        resolve(data)
      })
      .catch(reject)
    })
  }

  /**
   * Upgraded read raw with field selection
   * @param {SelectOption} selectOption Select options
   */
  select(selectOption) {
    if(!selectOption) selectOption = {}
    return new Promise((resolve, reject) => {
      this.__get_request({
        'collection': this.collectionName,
        'command': 'select',
        'select': selectOption
      }).then(data => {
        Object.keys(data).forEach(key => {
          data[key][ID_FIELD_NAME] = key
          this.addMethods(data[key])
        })

        resolve(data)
      })
      .catch(reject)
    })
  }

  /**
   * Returns random max entries offsetted with a given seed
   * @param {Integer} max 
   * @param {Integer} seed 
   * @param {Integer} offset 
   * @returns {Promise} entries
   */
  random(max, seed, offset) {
    const params = {}
    if(max !== undefined) {
      if(typeof(max) !== 'number' || !Number.isInteger(max) || max &lt; -1) return Promise.reject(new Error('Expected integer >= -1 for the max'))
      params.max = max
    }

    const hasSeed = seed !== undefined
    const hasOffset = offset !== undefined
    if(hasOffset &amp;&amp; !hasSeed) return Promise.reject(new Error('You can\'t put an offset without a seed'))

    if(hasOffset &amp;&amp; (typeof(offset) !== 'number' || !Number.isInteger(offset) || offset &lt; 0)) return Promise.reject(new Error('Expected integer >= -1 for the max'))
    
    if(hasSeed) {
      if((typeof(seed) !== 'number' || !Number.isInteger(seed))) return Promise.reject(new Error('Expected integer for the seed'))
      
      if(!hasOffset) offset = 0
      params.seed = seed
      params.offset = offset
    }

    return this.__get_request({
      'collection': this.collectionName,
      'command': 'random',
      'random': params
    }).then(data => {
      Object.keys(data).forEach(key => {
        data[key][ID_FIELD_NAME] = key
        this.addMethods(data[key])
      })

      return Promise.resolve(data)
    })
  }

  /**
   * creates write requests with given value
   * @private
   * @ignore
   * @param {String} command The write command you want
   * @param {Object?} value The value for this command 
   * @param {Boolean | undefined} multiple if I need to delete multiple 
   * @returns {Object} Write data object
   */
  __write_data(command, value = undefined, multiple = false) {
    const obj = {
      "token": writeToken(),
      "collection": this.collectionName,
      "command": command
    }
    if(multiple === true &amp;&amp; Array.isArray(value)) { // solves errors with undefined and null values
      value.forEach(v => {
        if(typeof value != 'number' &amp;&amp; typeof value != 'string' &amp;&amp; !Array.isArray(value)) 
          delete v[ID_FIELD_NAME]
      })
    } else if(multiple === false &amp;&amp; value != null &amp;&amp; value != undefined &amp;&amp; typeof value != 'number' &amp;&amp; typeof value != 'string' &amp;&amp; !Array.isArray(value)) { // solves errors with undefined and null values
      delete value[ID_FIELD_NAME]
    }
    if(value) {
      if(multiple)
        obj["values"] = value
      else
        obj["value"] = value
    }

    return obj
  }

  /**
   * Writes the raw JSON file
   * @param {Object} value The whole JSON to write
   * @returns {Promise&lt;any>}
   */
  write_raw(value) {
    if(value === undefined || value === null) {
      return Promise.reject(new Error('write_raw value must not be undefined or null'))
    }
    return this.__extract_data(axios.post(writeAddress(), this.__write_data('write_raw', value)))
  }

  /**
   * Add automatically a value to the JSON
   * @param {Object} value The value to add
   * @returns {Promise&lt;any>}
   */
  add(value) {
    return new Promise((resolve, reject) => {
      axios.post(writeAddress(), this.__write_data('add', value))
        .then(res => {
          return this.__extract_data(Promise.resolve(res))
        })
        .then(res => {
          if(typeof res != 'object' || !('id' in res) || typeof res.id != 'string') throw(new Error('Incorrect result'))
          resolve(res.id)
        })
        .catch(err => {
          reject(err)
        })
    })
  }

  /**
   * Add automatically multiple values to the JSON
   * @param {Object[]} values The values to add
   * @returns {Promise&lt;any>}
   */
  addBulk(values) {
    return new Promise((resolve, reject) => {
    this.__extract_data(axios.post(writeAddress(), this.__write_data('addBulk', values, true)))
      .then(res => {
        resolve(res.ids)
      })
      .catch(reject)
    })
  }

  /**
   * Remove entry with its key from the JSON
   * @param {String | Number} key The key from the entry to remove
   * @returns {Promise&lt;any>}
   */
  remove(key) {
    return this.__extract_data(axios.post(writeAddress(), this.__write_data('remove', key)))
  }

  /**
   * Remove entry with their keys from the JSON
   * @param {String[] | Number[]} keys The key from the entries to remove
   * @returns {Promise&lt;any>}
   */
  removeBulk(keys) {
    return this.__extract_data(axios.post(writeAddress(), this.__write_data('removeBulk', keys)))
  }

  /**
   * Sets an entry in the JSON
   * @param {String} key The key of the value you want to set
   * @param {Object} value The value you want for this key
   * @returns {Promise&lt;any>}
   */
  set(key, value) {
    const data = this.__write_data('set', value)
    data['key'] = key
    return this.__extract_data(axios.post(writeAddress(), data))
  }

  /**
   * Sets multiple entries in the JSON
   * @param {String[]} keys The array of keys of the values you want to set
   * @param {Object[]} values The values you want for these keys
   * @returns {Promise&lt;any>}
   */
  setBulk(keys, values) {
    const data = this.__write_data('setBulk', values, true)
    data['keys'] = keys
    return this.__extract_data(axios.post(writeAddress(), data))
  }

  /**
   * Changes one field from an element in this collection
   * @param {EditObject} obj The edit object
   * @returns {Promise&lt;any>}
   */
  editField(obj) {
    const data = this.__write_data('editField', obj, null)
    return this.__extract_data(axios.post(writeAddress(), data))
  }

  /**
   * Changes one field from an element in this collection
   * @param {EditObject[]} objArray The edit object array with operations
   * @returns {Promise&lt;any>}
   */
  editFieldBulk(objArray) {
    const data = this.__write_data('editFieldBulk', objArray, undefined)
    return this.__extract_data(axios.post(writeAddress(), data))
  }
}

const firestorm = {
  /**
   * @param {String} newValue The new address value
   */
  address: function(newValue = undefined) {
    if(newValue) _address = newValue

    return _address
  },

  /**
   * @param {String} newValue The new write token
   */
  token: function(newValue = undefined) {
    if(newValue) _token = newValue

    return _token
  },
  /**
   * @param {String} name Collection name to get
   * @param {Function?} addMethods Additional methods and data to add to the objects
   */
  collection: function(name, addMethods = el => el) {
    return new Collection(name, addMethods)
  },

  /**
   * 
   * @param {String} name Table name to get
   */
  table: function(name) {
    return this.collection(name)
  },

  ID_FIELD: ID_FIELD_NAME
}

try {
  if(typeof process === 'object') {
    module.exports = firestorm
  }
} catch (_error) {
  // normal browser
}</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Thu Jan 06 2022 09:30:18 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
